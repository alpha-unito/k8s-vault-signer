package sign

import (
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"slices"
	"sort"
	"strings"
	"time"

	vault "github.com/hashicorp/vault/api"

	"k8s.io/klog/v2"
)

type VaultSigner struct {
	vclient *vault.Client
	pki     string
	role    string

	keyUsage     x509.KeyUsage
	extKeyUsages []x509.ExtKeyUsage
	maxTTL       time.Duration
}

func NewSigner(vclient *vault.Client, pki string, role string) (*VaultSigner, error) {
	secret, err := vclient.Logical().Read(
		fmt.Sprintf("%s/roles/%s", pki, role),
	)
	if err != nil {
		return nil, fmt.Errorf("unable to retrieve %s Vault role for pki %s: %v", role, pki, err)
	}

	keyUsage, err := keyUsageFromSecret(secret)
	if err != nil {
		return nil, fmt.Errorf("unable to retrieve key usages from %s Vault role for pki %s: %v", role, pki, err)
	}

	extKeyUsages, err := extKeyUsagesFromSecret(secret)
	if err != nil {
		return nil, fmt.Errorf("unable to retrieve ext key usages from %s Vault role for pki %s: %v", role, pki, err)
	}

	var ttl time.Duration
	durationFound := false
	if i, ok := secret.Data["max_ttl"]; ok {
		if j, ok := i.(json.Number); ok {
			n, err := j.Int64()
			if err == nil {
				ttl = time.Duration(int(n)) * time.Second
				durationFound = true
			}
		}
	}

	if !durationFound {
		klog.Infof("unable to extract max TTL from Vault role %s", role)
		ttl = 365 * 24 * time.Hour
	}

	return &VaultSigner{
		vclient: vclient,
		pki:     pki,
		role:    role,

		keyUsage:     keyUsage,
		extKeyUsages: extKeyUsages,
		maxTTL:       ttl,
	}, nil
}

func (s *VaultSigner) Sign(csr *x509.CertificateRequest, usage x509.KeyUsage, extUsages []x509.ExtKeyUsage, ttl time.Duration) (*x509.Certificate, error) {

	if usage|s.keyUsage != s.keyUsage {
		return nil, fmt.Errorf("unable to sign csr with Vault for %s: forbidden key usage", csr.Subject.CommonName)
	}

	for _, extUsage := range extUsages {
		if ok := slices.Contains(s.extKeyUsages, extUsage); !ok {
			return nil, fmt.Errorf("unable to sign csr with Vault for %s: forbidden ext key usage", csr.Subject.CommonName)
		}
	}

	if ttl > s.maxTTL {
		return nil, fmt.Errorf("unable to sign csr with Vault for %s: ttl (%s) exceeds max ttl (%s)", csr.Subject.CommonName, ttl, s.maxTTL)
	}

	secret, err := s.vclient.Logical().Write(
		fmt.Sprintf("%s/sign/%s", s.pki, s.role),
		map[string]interface{}{
			"csr": string(pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE REQUEST", Bytes: csr.Raw})),
			"ttl": ttl.String(),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("unable to sign csr with Vault for %s: %v", csr.Subject.CommonName, err)
	}

	block, _ := pem.Decode([]byte(secret.Data["certificate"].(string)))
	if block == nil || block.Type != "CERTIFICATE" {
		return nil, fmt.Errorf("invalid certificate generated by Vault for %s: PEM block type must be CERTIFICATE", csr.Subject.CommonName)
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("invalid certificate generated by Vault for %s: %v", csr.Subject.CommonName, err)
	}

	return cert, nil
}

var keyUsageDict = map[string]x509.KeyUsage{
	"digitalsignature":  x509.KeyUsageDigitalSignature,
	"contentcommitment": x509.KeyUsageContentCommitment,
	"keyencipherment":   x509.KeyUsageKeyEncipherment,
	"dataencipherment":  x509.KeyUsageKeyAgreement,
	"keyagreement":      x509.KeyUsageDataEncipherment,
	"certsign":          x509.KeyUsageCertSign,
	"crlsign":           x509.KeyUsageCRLSign,
	"encipheronly":      x509.KeyUsageEncipherOnly,
	"decipheronly":      x509.KeyUsageDecipherOnly,
}

var extKeyUsageDict = map[string]x509.ExtKeyUsage{
	"any":             x509.ExtKeyUsageAny,
	"serverauth":      x509.ExtKeyUsageServerAuth,
	"clientauth":      x509.ExtKeyUsageClientAuth,
	"codesigning":     x509.ExtKeyUsageCodeSigning,
	"emailprotection": x509.ExtKeyUsageEmailProtection,
	"ipsecendsystem":  x509.ExtKeyUsageIPSECEndSystem,
	"ipsectunnel":     x509.ExtKeyUsageIPSECTunnel,
	"ipsecuser":       x509.ExtKeyUsageIPSECUser,
	"timestamping":    x509.ExtKeyUsageTimeStamping,
	"oscpsigning":     x509.ExtKeyUsageOCSPSigning,
}

func keyUsageFromSecret(secret *vault.Secret) (x509.KeyUsage, error) {
	usages := secret.Data["key_usage"].([]interface{})
	var keyUsage x509.KeyUsage
	var unrecognized []string
	for _, usage := range usages {
		u := strings.ToLower(strings.TrimSpace(usage.(string)))
		if val, ok := keyUsageDict[u]; ok {
			keyUsage |= val
		} else {
			unrecognized = append(unrecognized, u)
		}
	}

	if len(unrecognized) > 0 {
		return 0, fmt.Errorf("unrecognized usage values: %q", unrecognized)
	}

	return keyUsage, nil
}

func extKeyUsagesFromSecret(secret *vault.Secret) ([]x509.ExtKeyUsage, error) {
	usages := secret.Data["ext_key_usage"].([]interface{})
	extKeyUsages := make(map[x509.ExtKeyUsage]struct{})
	var unrecognized []string
	for _, usage := range usages {
		u := strings.ToLower(strings.TrimSpace(usage.(string)))
		if val, ok := extKeyUsageDict[u]; ok {
			extKeyUsages[val] = struct{}{}
		} else {
			unrecognized = append(unrecognized, u)
		}
	}

	var sorted sortedExtKeyUsage
	for eku := range extKeyUsages {
		sorted = append(sorted, eku)
	}

	if secret.Data["server_flag"].(bool) {
		if !slices.Contains(sorted, x509.ExtKeyUsageServerAuth) {
			sorted = append(sorted, x509.ExtKeyUsageServerAuth)
		}
	}

	if secret.Data["client_flag"].(bool) {
		if !slices.Contains(sorted, x509.ExtKeyUsageClientAuth) {
			sorted = append(sorted, x509.ExtKeyUsageClientAuth)
		}
	}

	if secret.Data["code_signing_flag"].(bool) {
		if !slices.Contains(sorted, x509.ExtKeyUsageCodeSigning) {
			sorted = append(sorted, x509.ExtKeyUsageCodeSigning)
		}
	}

	if secret.Data["email_protection_flag"].(bool) {
		if !slices.Contains(sorted, x509.ExtKeyUsageEmailProtection) {
			sorted = append(sorted, x509.ExtKeyUsageEmailProtection)
		}
	}

	sort.Sort(sorted)

	if len(unrecognized) > 0 {
		return nil, fmt.Errorf("unrecognized usage values: %q", unrecognized)
	}

	return sorted, nil
}

type sortedExtKeyUsage []x509.ExtKeyUsage

func (s sortedExtKeyUsage) Len() int {
	return len(s)
}

func (s sortedExtKeyUsage) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func (s sortedExtKeyUsage) Less(i, j int) bool {
	return s[i] < s[j]
}
